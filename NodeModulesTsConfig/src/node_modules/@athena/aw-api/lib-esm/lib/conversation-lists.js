"use strict";
import ApiClass from './api';
/**
 *
 * @class ConversationLists
 * @param {(string)} [domainOrOptions] - The project domain.
 */
export default class ConversationLists extends ApiClass {
    GetSponsorOrganizationConversationsURL(parameters) {
        let queryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/conversations';
        path = path.replace('{distributorId}', `${parameters['distributorId']}`);
        path = path.replace('{sponsorId}', `${parameters['sponsorId']}`);
        if (parameters['fromDateTime'] !== undefined) {
            queryParameters['fromDateTime'] = parameters['fromDateTime'];
        }
        if (parameters['toDateTime'] !== undefined) {
            queryParameters['toDateTime'] = parameters['toDateTime'];
        }
        if (parameters['tags'] !== undefined) {
            queryParameters['tags'] = parameters['tags'];
        }
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }
    /**
    * This is a method that retrieves a list of all of a sponsor's organization conversations,
                    optionally within a specified date range. The organization list is constrained to the organizations
                    which the calling user has a right to view.
    * @method
    * @name ConversationLists#GetSponsorOrganizationConversations
         * @param {string} distributorId - The distributor identifier.
         * @param {string} sponsorId - The sponsor identifier.
         * @param {string} fromDateTime - The beginning point, in UTC, from which to search for conversations, inclusive. May be
                    omitted.
         * @param {string} toDateTime - The endpoints point, in UTC, to which to search for conversations, inclusive.
                    May be omitted.
         * @param {string} tags - A CSV list of tags that may be used to filter which conversations are returned. Placing an ! in front of
                    a tag (e.g. !Inbox) will result in conversations with that tag being excluded. If more than one tag is present in
                    the list,
                    all tags must be present on the conversation in order for it to be included. Parameter is optional.
         * @param {string} authorization - access token
    */
    GetSponsorOrganizationConversations(parameters) {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/conversations';
        let body;
        let queryParameters = {};
        let headers = {};
        let form = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{distributorId}', `${parameters['distributorId']}`);
            if (parameters['distributorId'] === undefined) {
                reject(new Error('Missing required  parameter: distributorId'));
                return;
            }
            path = path.replace('{sponsorId}', `${parameters['sponsorId']}`);
            if (parameters['sponsorId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorId'));
                return;
            }
            if (parameters['fromDateTime'] !== undefined) {
                queryParameters['fromDateTime'] = parameters['fromDateTime'];
            }
            if (parameters['toDateTime'] !== undefined) {
                queryParameters['toDateTime'] = parameters['toDateTime'];
            }
            if (parameters['tags'] !== undefined) {
                queryParameters['tags'] = parameters['tags'];
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }
    GetSponsorOrganizationConversationsMetaDataURL(parameters) {
        let queryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/conversations/metadata';
        path = path.replace('{distributorId}', `${parameters['distributorId']}`);
        path = path.replace('{sponsorId}', `${parameters['sponsorId']}`);
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }
    /**
    * This is a method that retrieves metadata about all the conversations in a sponsor's organizations.
                    The organizations are constrained to those the caller can see.
    * @method
    * @name ConversationLists#GetSponsorOrganizationConversationsMetaData
         * @param {string} distributorId - The distributor identifier.
         * @param {string} sponsorId - The sponsor identifier.
         * @param {string} authorization - access token
    */
    GetSponsorOrganizationConversationsMetaData(parameters) {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/conversations/metadata';
        let body;
        let queryParameters = {};
        let headers = {};
        let form = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{distributorId}', `${parameters['distributorId']}`);
            if (parameters['distributorId'] === undefined) {
                reject(new Error('Missing required  parameter: distributorId'));
                return;
            }
            path = path.replace('{sponsorId}', `${parameters['sponsorId']}`);
            if (parameters['sponsorId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorId'));
                return;
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }
    GetOrganizationConversationsURL(parameters) {
        let queryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/organizations/{organizationId}/conversations';
        path = path.replace('{distributorId}', `${parameters['distributorId']}`);
        path = path.replace('{sponsorId}', `${parameters['sponsorId']}`);
        path = path.replace('{organizationId}', `${parameters['organizationId']}`);
        if (parameters['fromDateTime'] !== undefined) {
            queryParameters['fromDateTime'] = parameters['fromDateTime'];
        }
        if (parameters['toDateTime'] !== undefined) {
            queryParameters['toDateTime'] = parameters['toDateTime'];
        }
        if (parameters['tags'] !== undefined) {
            queryParameters['tags'] = parameters['tags'];
        }
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }
    /**
    * This is a method that retrieves a list of all of an organization's conversations, optionally within a specified date range.
    * @method
    * @name ConversationLists#GetOrganizationConversations
         * @param {string} distributorId - The distributor identifier.
         * @param {string} sponsorId - The sponsor identifier.
         * @param {string} organizationId - The organization identifier.
         * @param {string} fromDateTime - The beginning point, in UTC, from which to search for conversations, inclusive. May be
                    omitted.
         * @param {string} toDateTime - The endpoints point, in UTC, to which to search for conversations, inclusive. May be omitted.
         * @param {string} tags - A CSV list of tags that may be used to filter which conversations are returned. Placing an ! in front of
                    a tag (e.g. !Inbox) will result in conversations with that tag being excluded. If more than one tag is present in
                    the list,
                    all tags must be present on the conversation in order for it to be included. Parameter is optional.
         * @param {string} authorization - access token
    */
    GetOrganizationConversations(parameters) {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/organizations/{organizationId}/conversations';
        let body;
        let queryParameters = {};
        let headers = {};
        let form = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{distributorId}', `${parameters['distributorId']}`);
            if (parameters['distributorId'] === undefined) {
                reject(new Error('Missing required  parameter: distributorId'));
                return;
            }
            path = path.replace('{sponsorId}', `${parameters['sponsorId']}`);
            if (parameters['sponsorId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorId'));
                return;
            }
            path = path.replace('{organizationId}', `${parameters['organizationId']}`);
            if (parameters['organizationId'] === undefined) {
                reject(new Error('Missing required  parameter: organizationId'));
                return;
            }
            if (parameters['fromDateTime'] !== undefined) {
                queryParameters['fromDateTime'] = parameters['fromDateTime'];
            }
            if (parameters['toDateTime'] !== undefined) {
                queryParameters['toDateTime'] = parameters['toDateTime'];
            }
            if (parameters['tags'] !== undefined) {
                queryParameters['tags'] = parameters['tags'];
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }
    GetUserConversationsURL(parameters) {
        let queryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/users/{userId}/conversations';
        path = path.replace('{distributorId}', `${parameters['distributorId']}`);
        path = path.replace('{sponsorId}', `${parameters['sponsorId']}`);
        path = path.replace('{userId}', `${parameters['userId']}`);
        if (parameters['fromDateTime'] !== undefined) {
            queryParameters['fromDateTime'] = parameters['fromDateTime'];
        }
        if (parameters['toDateTime'] !== undefined) {
            queryParameters['toDateTime'] = parameters['toDateTime'];
        }
        if (parameters['tags'] !== undefined) {
            queryParameters['tags'] = parameters['tags'];
        }
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }
    /**
    * This is a method that retrieves a list of all of a user's conversations, optionally within a specified date range.
    * @method
    * @name ConversationLists#GetUserConversations
         * @param {string} distributorId - The distributor identifier.
         * @param {string} sponsorId - The sponsor identifier.
         * @param {string} userId - The user identifier.
         * @param {string} fromDateTime - The beginning point, in UTC, from which to search for conversations, inclusive. May be omitted.
         * @param {string} toDateTime - The endpoints point, in UTC, to which to search for conversations, inclusive. May be omitted.
         * @param {string} tags - A CSV list of tags that may be used to filter which conversations are returned. Placing an ! in front of
                    a tag (e.g. !Inbox) will result in conversations with that tag being excluded. If more than one tag is present in
                    the list,
                    all tags must be present on the conversation in order for it to be included. Parameter is optional.
         * @param {string} authorization - access token
    */
    GetUserConversations(parameters) {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/users/{userId}/conversations';
        let body;
        let queryParameters = {};
        let headers = {};
        let form = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{distributorId}', `${parameters['distributorId']}`);
            if (parameters['distributorId'] === undefined) {
                reject(new Error('Missing required  parameter: distributorId'));
                return;
            }
            path = path.replace('{sponsorId}', `${parameters['sponsorId']}`);
            if (parameters['sponsorId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorId'));
                return;
            }
            path = path.replace('{userId}', `${parameters['userId']}`);
            if (parameters['userId'] === undefined) {
                reject(new Error('Missing required  parameter: userId'));
                return;
            }
            if (parameters['fromDateTime'] !== undefined) {
                queryParameters['fromDateTime'] = parameters['fromDateTime'];
            }
            if (parameters['toDateTime'] !== undefined) {
                queryParameters['toDateTime'] = parameters['toDateTime'];
            }
            if (parameters['tags'] !== undefined) {
                queryParameters['tags'] = parameters['tags'];
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }
    GetPatientConversationsURL(parameters) {
        let queryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/conversations';
        path = path.replace('{patientId}', `${parameters['patientId']}`);
        if (parameters['fromDateTime'] !== undefined) {
            queryParameters['fromDateTime'] = parameters['fromDateTime'];
        }
        if (parameters['toDateTime'] !== undefined) {
            queryParameters['toDateTime'] = parameters['toDateTime'];
        }
        if (parameters['tags'] !== undefined) {
            queryParameters['tags'] = parameters['tags'];
        }
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }
    /**
    * This is a method that retrieves a list of all of a patient's conversations, optionally within a specified date range.
    * @method
    * @name ConversationLists#GetPatientConversations
         * @param {string} patientId - The patient identifier.
         * @param {string} fromDateTime - The beginning point, in UTC, from which to search for conversations, inclusive. May be omitted.
         * @param {string} toDateTime - The endpoints point, in UTC, to which to search for conversations, inclusive. May be omitted.
         * @param {string} tags - A CSV list of tags that may be used to filter which conversations are returned. Placing an ! in front of
                    a tag (e.g. !Inbox) will result in conversations with that tag being excluded. If more than one tag is present in
                    the list,
                    all tags must be present on the conversation in order for it to be included. Parameter is optional
         * @param {string} authorization - access token
    */
    GetPatientConversations(parameters) {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/conversations';
        let body;
        let queryParameters = {};
        let headers = {};
        let form = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{patientId}', `${parameters['patientId']}`);
            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }
            if (parameters['fromDateTime'] !== undefined) {
                queryParameters['fromDateTime'] = parameters['fromDateTime'];
            }
            if (parameters['toDateTime'] !== undefined) {
                queryParameters['toDateTime'] = parameters['toDateTime'];
            }
            if (parameters['tags'] !== undefined) {
                queryParameters['tags'] = parameters['tags'];
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }
    GetPatientConversationsSponsorIdentifierURL(parameters) {
        let queryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/patients/{patientId}/conversations';
        path = path.replace('{distributorId}', `${parameters['distributorId']}`);
        path = path.replace('{sponsorId}', `${parameters['sponsorId']}`);
        path = path.replace('{patientId}', `${parameters['patientId']}`);
        if (parameters['fromDateTime'] !== undefined) {
            queryParameters['fromDateTime'] = parameters['fromDateTime'];
        }
        if (parameters['toDateTime'] !== undefined) {
            queryParameters['toDateTime'] = parameters['toDateTime'];
        }
        if (parameters['tags'] !== undefined) {
            queryParameters['tags'] = parameters['tags'];
        }
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }
    /**
    * This is a method that retrieves a list of all of a patient's conversations, optionally within a specified date range.
    * @method
    * @name ConversationLists#GetPatientConversationsSponsorIdentifier
         * @param {string} distributorId - The distributor identifier.
         * @param {string} sponsorId - The sponsor identifier.
         * @param {string} patientId - The patient identifier.
         * @param {string} fromDateTime - The beginning point, in UTC, from which to search for conversations, inclusive. May be omitted.
         * @param {string} toDateTime - The endpoints point, in UTC, to which to search for conversations, inclusive. May be omitted.
         * @param {string} tags - A CSV list of tags that may be used to filter which conversations are returned. Placing an ! in front of
                    a tag (e.g. !Inbox) will result in conversations with that tag being excluded. If more than one tag is present in
                    the list,
                    all tags must be present on the conversation in order for it to be included. Parameter is optional
         * @param {string} authorization - access token
    */
    GetPatientConversationsSponsorIdentifier(parameters) {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/patients/{patientId}/conversations';
        let body;
        let queryParameters = {};
        let headers = {};
        let form = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{distributorId}', `${parameters['distributorId']}`);
            if (parameters['distributorId'] === undefined) {
                reject(new Error('Missing required  parameter: distributorId'));
                return;
            }
            path = path.replace('{sponsorId}', `${parameters['sponsorId']}`);
            if (parameters['sponsorId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorId'));
                return;
            }
            path = path.replace('{patientId}', `${parameters['patientId']}`);
            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }
            if (parameters['fromDateTime'] !== undefined) {
                queryParameters['fromDateTime'] = parameters['fromDateTime'];
            }
            if (parameters['toDateTime'] !== undefined) {
                queryParameters['toDateTime'] = parameters['toDateTime'];
            }
            if (parameters['tags'] !== undefined) {
                queryParameters['tags'] = parameters['tags'];
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }
}
//# sourceMappingURL=conversation-lists.js.map