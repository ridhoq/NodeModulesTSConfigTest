import * as request from "superagent";
import * as Api from './api';
import ApiClass from './api';

/**
 * 
 * @class PatientInternal
 * @param {(string)} [domainOrOptions] - The project domain.
 */
export default class PatientInternal extends ApiClass {

    ActivateWithSponsorNameURL(parameters: {
        sponsorName: string,
        model: Api.ActivatePatientDobSponsorPatientIdBindingModel,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{sponsorName}/activate';

        path = path.replace('{sponsorName}', `${parameters['sponsorName']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that activates a patient which is currently in inactive state.
     * @method
     * @name PatientInternal#ActivateWithSponsorName
     * @param {string} sponsorName - The sponsor identifier.
     * @param {} model - The model.
     */
    ActivateWithSponsorName(parameters: {
        sponsorName: string,
        model: Api.ActivatePatientDobSponsorPatientIdBindingModel,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{sponsorName}/activate';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            path = path.replace('{sponsorName}', `${parameters['sponsorName']}`);

            if (parameters['sponsorName'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorName'));
                return;
            }

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    IsPatientDeactivatedURL(parameters: {
        sponsorPatientId: string,
        dateOfBirth: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/activate';
        if (parameters['sponsorPatientId'] !== undefined) {
            queryParameters['sponsorPatientId'] = parameters['sponsorPatientId'];
        }

        if (parameters['dateOfBirth'] !== undefined) {
            queryParameters['dateOfBirth'] = parameters['dateOfBirth'];
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that determines whether the patient is deactivated.
     * @method
     * @name PatientInternal#IsPatientDeactivated
     * @param {string} sponsorPatientId - The sponsor patient identifier.
     * @param {string} dateOfBirth - The date of birth.
     */
    IsPatientDeactivated(parameters: {
        sponsorPatientId: string,
        dateOfBirth: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/activate';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            if (parameters['sponsorPatientId'] !== undefined) {
                queryParameters['sponsorPatientId'] = parameters['sponsorPatientId'];
            }

            if (parameters['sponsorPatientId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorPatientId'));
                return;
            }

            if (parameters['dateOfBirth'] !== undefined) {
                queryParameters['dateOfBirth'] = parameters['dateOfBirth'];
            }

            if (parameters['dateOfBirth'] === undefined) {
                reject(new Error('Missing required  parameter: dateOfBirth'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    ActivateURL(parameters: {
        model: Api.ActivatePatientDobSponsorPatientIdBindingModel,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/activate';

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that activates a patient which is currently in inactivate state.
     * @method
     * @name PatientInternal#Activate
     * @param {} model - The activate patient with date of birth and sponsor patient id model.
     */
    Activate(parameters: {
        model: Api.ActivatePatientDobSponsorPatientIdBindingModel,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/activate';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    AddCarePlansToPatientURL(parameters: {
        patientId: string,
        model: Api.IdListBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/careplans';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * This is a method that associates a care plan to a patient. A patient can be associated
                    to multiple care plans. A care plan is not owned by a patient unless it is a "personal
                    care plan." A patient can have only one personal care plan at a time, and may not mix
                    a personal care plan with other population level care plans.
    * @method
    * @name PatientInternal#AddCarePlansToPatient
         * @param {string} patientId - The internal Patient IO patient identifier.
         * @param {} model - The list of care plans to assign to the patient.
         * @param {string} authorization - access token
    */
    AddCarePlansToPatient(parameters: {
        patientId: string,
        model: Api.IdListBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/careplans';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    AddCategoriesToPatientURL(parameters: {
        patientId: string,
        model: Api.IdListBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/categories';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * This is a method that adds categories to the patient.
                    Categories are known as groups within the dashboard UI.
    * @method
    * @name PatientInternal#AddCategoriesToPatient
         * @param {string} patientId - The internal Patient IO patient identifier.
         * @param {} model - The categories to assign to the patient.
         * @param {string} authorization - access token
    */
    AddCategoriesToPatient(parameters: {
        patientId: string,
        model: Api.IdListBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/categories';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    AffiliatePatientFromOrganizationURL(parameters: {
        patientId: string,
        model: Api.IdBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/organizations';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that affiliates a patient to an organization or organizations.
     * @method
     * @name PatientInternal#AffiliatePatientFromOrganization
     * @param {string} patientId - The internal Patient IO patient identifier.
     * @param {} model - The list of organization ids.
     * @param {string} authorization - access token
     */
    AffiliatePatientFromOrganization(parameters: {
        patientId: string,
        model: Api.IdBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/organizations';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    ChangePasswordURL(parameters: {
        patientId: string,
        model: Api.ChangePasswordBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/password';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * This is a method that allows a patient to change his password. This API relies
                    on the calling used being authorized in the system and knowing the existing password.
                    Higher privilege users may reset the password using this API without knowing the
                    existing password.
    * @method
    * @name PatientInternal#ChangePassword
         * @param {string} patientId - The internal Patient IO patient identifier.
         * @param {} model - The old and new passwords.
         * @param {string} authorization - access token
    */
    ChangePassword(parameters: {
        patientId: string,
        model: Api.ChangePasswordBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/password';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    ChangePatientRoleInternalURL(parameters: {
        patientId: string,
        model: Api.PatientChangeRoleBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/roles';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that changes patient's role.
     * @method
     * @name PatientInternal#ChangePatientRoleInternal
     * @param {string} patientId - The internal Patient IO patient identifier.
     * @param {} model - The patient role change model.
     * @param {string} authorization - access token
     */
    ChangePatientRoleInternal(parameters: {
        patientId: string,
        model: Api.PatientChangeRoleBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/roles';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    AddRolesURL(parameters: {
        patientId: string,
        model: Api.RoleBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/roles';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * Adds roles to a patient.
     * @method
     * @name PatientInternal#AddRoles
     * @param {string} patientId - The patient identifier.
     * @param {} model - The roles to add.
     * @param {string} authorization - access token
     */
    AddRoles(parameters: {
        patientId: string,
        model: Api.RoleBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/roles';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    ChangePatientSettingsInternalURL(parameters: {
        patientId: string,
        model: Api.PatientSettingsBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/settings';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that changes patient settings.
     * @method
     * @name PatientInternal#ChangePatientSettingsInternal
     * @param {string} patientId - The internal Patient IO patient identifier.
     * @param {} model - The model.
     * @param {string} authorization - access token
     */
    ChangePatientSettingsInternal(parameters: {
        patientId: string,
        model: Api.PatientSettingsBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/settings';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    ClearPatientAlertsURL(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/alerts';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that clears all active alerts on the patient.
     * @method
     * @name PatientInternal#ClearPatientAlerts
     * @param {string} patientId - The internal Patient IO patient identifier.
     * @param {string} authorization - access token
     */
    ClearPatientAlerts(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/alerts';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    UploadPhotoURL(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/photo';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * This is a method that adds or updates a photo for the patient.
                    This endpoint requires use of mime multipart content, not json.
    * @method
    * @name PatientInternal#UploadPhoto
         * @param {string} patientId - The internal Patient IO patient identifier.
         * @param {string} authorization - access token
    */
    UploadPhoto(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/photo';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    DeletePhotoURL(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/photo';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that deletes a patient's profile photo.
     * @method
     * @name PatientInternal#DeletePhoto
     * @param {string} patientId - The internal Patient IO patient identifier.
     * @param {string} authorization - access token
     */
    DeletePhoto(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/photo';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    GetCompletedTaskReadModelsURL(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/tasks';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that retrieves tasks a patient has completed.
     * @method
     * @name PatientInternal#GetCompletedTaskReadModels
     * @param {string} patientId - The internal Patient IO patient identifier.
     * @param {string} authorization - access token
     */
    GetCompletedTaskReadModels(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/tasks';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    GetTaskOutcomesOverTimeURL(parameters: {
        patientId: string,
        taskId: string,
        startDate: string,
        endDate: string,
        intervalType: "Day" | "Month",
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/tasks/{taskId}';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        path = path.replace('{taskId}', `${parameters['taskId']}`);
        if (parameters['startDate'] !== undefined) {
            queryParameters['startDate'] = parameters['startDate'];
        }

        if (parameters['endDate'] !== undefined) {
            queryParameters['endDate'] = parameters['endDate'];
        }

        if (parameters['intervalType'] !== undefined) {
            queryParameters['intervalType'] = parameters['intervalType'];
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that retrieves the patients task outcomes over time.
     * @method
     * @name PatientInternal#GetTaskOutcomesOverTime
     * @param {string} patientId - The internal Patient IO patient identifier.
     * @param {string} taskId - The task identifier.
     * @param {string} startDate - yyyy-MM-dd
     * @param {string} endDate - yyyy-MM-dd
     * @param {string} intervalType - The period of time the results should be grouped by.
     * @param {string} authorization - access token
     */
    GetTaskOutcomesOverTime(parameters: {
        patientId: string,
        taskId: string,
        startDate: string,
        endDate: string,
        intervalType: "Day" | "Month",
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/tasks/{taskId}';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            path = path.replace('{taskId}', `${parameters['taskId']}`);

            if (parameters['taskId'] === undefined) {
                reject(new Error('Missing required  parameter: taskId'));
                return;
            }

            if (parameters['startDate'] !== undefined) {
                queryParameters['startDate'] = parameters['startDate'];
            }

            if (parameters['startDate'] === undefined) {
                reject(new Error('Missing required  parameter: startDate'));
                return;
            }

            if (parameters['endDate'] !== undefined) {
                queryParameters['endDate'] = parameters['endDate'];
            }

            if (parameters['endDate'] === undefined) {
                reject(new Error('Missing required  parameter: endDate'));
                return;
            }

            if (parameters['intervalType'] !== undefined) {
                queryParameters['intervalType'] = parameters['intervalType'];
            }

            if (parameters['intervalType'] === undefined) {
                reject(new Error('Missing required  parameter: intervalType'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    PushScheduleUpdateURL(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/pushscheduleupdate';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * This is a method that pushes a schedule update to the patient immediately.
                    This call is used if a patient's care plan(s) has changed, and we want to
                    update today's tasks right away rather than leaving them stable according 
                    to the previous care plan assignments.
    * @method
    * @name PatientInternal#PushScheduleUpdate
         * @param {string} patientId - The internal Patient IO patient identifier.
         * @param {string} authorization - access token
    */
    PushScheduleUpdate(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/pushscheduleupdate';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    ReplacePatientCarePlanURL(parameters: {
        patientId: string,
        carePlanId: string,
        model: Api.IdBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/careplans/{carePlanId}';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        path = path.replace('{carePlanId}', `${parameters['carePlanId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * This is a method that updates a patient's care plan to another care plan.
                    That is, swap one care plan for another. This method works on Personal and Population
                    Care Plans, but not on Patient care plans, which cannot be removed.
    * @method
    * @name PatientInternal#ReplacePatientCarePlan
         * @param {string} patientId - The internal Patient IO patient identifier.
         * @param {string} carePlanId - The care plan identifier.
         * @param {} model - The list of care plan ids to swap in.
         * @param {string} authorization - access token
    */
    ReplacePatientCarePlan(parameters: {
        patientId: string,
        carePlanId: string,
        model: Api.IdBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/careplans/{carePlanId}';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            path = path.replace('{carePlanId}', `${parameters['carePlanId']}`);

            if (parameters['carePlanId'] === undefined) {
                reject(new Error('Missing required  parameter: carePlanId'));
                return;
            }

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    RemoveCarePlanFromPatientURL(parameters: {
        patientId: string,
        carePlanId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/careplans/{carePlanId}';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        path = path.replace('{carePlanId}', `${parameters['carePlanId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * This is a method that removes a population or personal care plan from a patient.
                    This method does not operate on Patient care plans.
    * @method
    * @name PatientInternal#RemoveCarePlanFromPatient
         * @param {string} patientId - The internal Patient IO patient identifier.
         * @param {string} carePlanId - The care plan identifier.
         * @param {string} authorization - access token
    */
    RemoveCarePlanFromPatient(parameters: {
        patientId: string,
        carePlanId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/careplans/{carePlanId}';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            path = path.replace('{carePlanId}', `${parameters['carePlanId']}`);

            if (parameters['carePlanId'] === undefined) {
                reject(new Error('Missing required  parameter: carePlanId'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    ReplacePatientCategoryURL(parameters: {
        patientId: string,
        categoryId: string,
        model: Api.IdBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/categories/{categoryId}';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        path = path.replace('{categoryId}', `${parameters['categoryId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * This is a method that updates a patient's category to another category.
                    That is, swap one category for another.
    * @method
    * @name PatientInternal#ReplacePatientCategory
         * @param {string} patientId - The internal Patient IO patient identifier.
         * @param {string} categoryId - The category identifier.
         * @param {} model - The list of category ids to swap in.
         * @param {string} authorization - access token
    */
    ReplacePatientCategory(parameters: {
        patientId: string,
        categoryId: string,
        model: Api.IdBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/categories/{categoryId}';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            path = path.replace('{categoryId}', `${parameters['categoryId']}`);

            if (parameters['categoryId'] === undefined) {
                reject(new Error('Missing required  parameter: categoryId'));
                return;
            }

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    RemoveCategoryFromPatientURL(parameters: {
        patientId: string,
        categoryId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/categories/{categoryId}';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        path = path.replace('{categoryId}', `${parameters['categoryId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that removes a category from a patient.
     * @method
     * @name PatientInternal#RemoveCategoryFromPatient
     * @param {string} patientId - The internal Patient IO patient identifier.
     * @param {string} categoryId - The category identifier.
     * @param {string} authorization - access token
     */
    RemoveCategoryFromPatient(parameters: {
        patientId: string,
        categoryId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/categories/{categoryId}';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            path = path.replace('{categoryId}', `${parameters['categoryId']}`);

            if (parameters['categoryId'] === undefined) {
                reject(new Error('Missing required  parameter: categoryId'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    UnaffiliatePatientFromOrganizationURL(parameters: {
        patientId: string,
        organizationId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/organizations/{organizationId}';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        path = path.replace('{organizationId}', `${parameters['organizationId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that unaffiliates a patient from an organization.
     * @method
     * @name PatientInternal#UnaffiliatePatientFromOrganization
     * @param {string} patientId - The internal Patient IO patient identifier.
     * @param {string} organizationId - The organization which should be removed from the patient.
     * @param {string} authorization - access token
     */
    UnaffiliatePatientFromOrganization(parameters: {
        patientId: string,
        organizationId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/organizations/{organizationId}';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            path = path.replace('{organizationId}', `${parameters['organizationId']}`);

            if (parameters['organizationId'] === undefined) {
                reject(new Error('Missing required  parameter: organizationId'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    GetSignaledAlertsURL(parameters: {
        distributorId: string,
        sponsorId: string,
        patientId: string,
        fromDate: string,
        toDate: string,
        activeOnly ? : boolean,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/signaledalerts';
        if (parameters['distributorId'] !== undefined) {
            queryParameters['distributorId'] = parameters['distributorId'];
        }

        if (parameters['sponsorId'] !== undefined) {
            queryParameters['sponsorId'] = parameters['sponsorId'];
        }

        path = path.replace('{patientId}', `${parameters['patientId']}`);
        if (parameters['fromDate'] !== undefined) {
            queryParameters['fromDate'] = parameters['fromDate'];
        }

        if (parameters['toDate'] !== undefined) {
            queryParameters['toDate'] = parameters['toDate'];
        }

        if (parameters['activeOnly'] !== undefined) {
            queryParameters['activeOnly'] = parameters['activeOnly'];
        }

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * Retrieves signaled alerts for the provided sponsor across a date range.
     * @method
     * @name PatientInternal#GetSignaledAlerts
     * @param {string} distributorId - The distributor identifier.
     * @param {string} sponsorId - The sponsor identifier.
     * @param {string} patientId - The patient identifier.
     * @param {string} fromDate - From date (inclusive).
     * @param {string} toDate - To date (inclusive).
     * @param {boolean} activeOnly - True if only active alerts should be returned.  False if all alerts should be returned.
     * @param {string} authorization - access token
     */
    GetSignaledAlerts(parameters: {
        distributorId: string,
        sponsorId: string,
        patientId: string,
        fromDate: string,
        toDate: string,
        activeOnly ? : boolean,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}/signaledalerts';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            if (parameters['distributorId'] !== undefined) {
                queryParameters['distributorId'] = parameters['distributorId'];
            }

            if (parameters['distributorId'] === undefined) {
                reject(new Error('Missing required  parameter: distributorId'));
                return;
            }

            if (parameters['sponsorId'] !== undefined) {
                queryParameters['sponsorId'] = parameters['sponsorId'];
            }

            if (parameters['sponsorId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorId'));
                return;
            }

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['fromDate'] !== undefined) {
                queryParameters['fromDate'] = parameters['fromDate'];
            }

            if (parameters['fromDate'] === undefined) {
                reject(new Error('Missing required  parameter: fromDate'));
                return;
            }

            if (parameters['toDate'] !== undefined) {
                queryParameters['toDate'] = parameters['toDate'];
            }

            if (parameters['toDate'] === undefined) {
                reject(new Error('Missing required  parameter: toDate'));
                return;
            }

            if (parameters['activeOnly'] !== undefined) {
                queryParameters['activeOnly'] = parameters['activeOnly'];
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    GetPatientURL(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * This is a method that retrieves patient data.
                    The data is constrained by caller access permissions.
    * @method
    * @name PatientInternal#GetPatient
         * @param {string} patientId - The internal Patient IO patient identifier.
         * @param {string} authorization - access token
    */
    GetPatient(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    UpdatePatientURL(parameters: {
        patientId: string,
        model: Api.PatientUpdateBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * This is a method that updates the patient's information.
                    If user name and email address are to be changed: set NewUserName,
                    leaving UserName as the original user name.
    * @method
    * @name PatientInternal#UpdatePatient
         * @param {string} patientId - The internal Patient IO patient identifier.
         * @param {} model - The patient update model.
         * @param {string} authorization - access token
    */
    UpdatePatient(parameters: {
        patientId: string,
        model: Api.PatientUpdateBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    DeletePatientURL(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}';

        path = path.replace('{patientId}', `${parameters['patientId']}`);

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
     * This is a method that permanently and finally deletes a patient record.
     * @method
     * @name PatientInternal#DeletePatient
     * @param {string} patientId - The internal Patient IO patient identifier.
     * @param {string} authorization - access token
     */
    DeletePatient(parameters: {
        patientId: string,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/{patientId}';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';

            path = path.replace('{patientId}', `${parameters['patientId']}`);

            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

    BulkPatientUpdateURL(parameters: {
        model: Api.InternalBulkPatientUpdateBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): string {
        let queryParameters: any = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/bulkUpdate';

        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Allows a care team member to bulk manage patients. 
                    The user can specify a collection of patients by ID to be managed. 
                    Supported operations include adding/removing the care plans, adding/removing
                    the categories, and changing the organization of each patient in the collection.
    * @method
    * @name PatientInternal#BulkPatientUpdate
         * @param {} model - The bulk patient update model
         * @param {string} authorization - access token
    */
    BulkPatientUpdate(parameters: {
        model: Api.InternalBulkPatientUpdateBindingModel,
        authorization: string,
        $queryParameters ? : any,
        $domain ? : string
    }): Promise < request.Response > {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/api/patients/bulkUpdate';
        let body: any;
        let queryParameters: any = {};
        let headers: any = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = 'application/json,text/json,application/xml,text/xml,application/x-www-form-urlencoded';

            if (parameters['model'] !== undefined) {
                body = parameters['model'];
            }

            if (parameters['model'] === undefined) {
                reject(new Error('Missing required  parameter: model'));
                return;
            }

            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }

            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }

            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function(parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    }

}