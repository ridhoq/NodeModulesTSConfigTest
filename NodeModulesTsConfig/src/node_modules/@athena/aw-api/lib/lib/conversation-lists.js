"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import ApiClass from './api';
/**
 *
 * @class ConversationLists
 * @param {(string)} [domainOrOptions] - The project domain.
 */
var ConversationLists = /** @class */ (function (_super) {
    __extends(ConversationLists, _super);
    function ConversationLists() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ConversationLists.prototype.GetSponsorOrganizationConversationsURL = function (parameters) {
        var queryParameters = {};
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/conversations';
        path = path.replace('{distributorId}', "" + parameters['distributorId']);
        path = path.replace('{sponsorId}', "" + parameters['sponsorId']);
        if (parameters['fromDateTime'] !== undefined) {
            queryParameters['fromDateTime'] = parameters['fromDateTime'];
        }
        if (parameters['toDateTime'] !== undefined) {
            queryParameters['toDateTime'] = parameters['toDateTime'];
        }
        if (parameters['tags'] !== undefined) {
            queryParameters['tags'] = parameters['tags'];
        }
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        var keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(function (key) { return key + '=' + encodeURIComponent(queryParameters[key]); }).join('&')) : '');
    };
    /**
    * This is a method that retrieves a list of all of a sponsor's organization conversations,
                    optionally within a specified date range. The organization list is constrained to the organizations
                    which the calling user has a right to view.
    * @method
    * @name ConversationLists#GetSponsorOrganizationConversations
         * @param {string} distributorId - The distributor identifier.
         * @param {string} sponsorId - The sponsor identifier.
         * @param {string} fromDateTime - The beginning point, in UTC, from which to search for conversations, inclusive. May be
                    omitted.
         * @param {string} toDateTime - The endpoints point, in UTC, to which to search for conversations, inclusive.
                    May be omitted.
         * @param {string} tags - A CSV list of tags that may be used to filter which conversations are returned. Placing an ! in front of
                    a tag (e.g. !Inbox) will result in conversations with that tag being excluded. If more than one tag is present in
                    the list,
                    all tags must be present on the conversation in order for it to be included. Parameter is optional.
         * @param {string} authorization - access token
    */
    ConversationLists.prototype.GetSponsorOrganizationConversations = function (parameters) {
        var _this = this;
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/conversations';
        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};
        return new Promise(function (resolve, reject) {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{distributorId}', "" + parameters['distributorId']);
            if (parameters['distributorId'] === undefined) {
                reject(new Error('Missing required  parameter: distributorId'));
                return;
            }
            path = path.replace('{sponsorId}', "" + parameters['sponsorId']);
            if (parameters['sponsorId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorId'));
                return;
            }
            if (parameters['fromDateTime'] !== undefined) {
                queryParameters['fromDateTime'] = parameters['fromDateTime'];
            }
            if (parameters['toDateTime'] !== undefined) {
                queryParameters['toDateTime'] = parameters['toDateTime'];
            }
            if (parameters['tags'] !== undefined) {
                queryParameters['tags'] = parameters['tags'];
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            _this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    };
    ConversationLists.prototype.GetSponsorOrganizationConversationsMetaDataURL = function (parameters) {
        var queryParameters = {};
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/conversations/metadata';
        path = path.replace('{distributorId}', "" + parameters['distributorId']);
        path = path.replace('{sponsorId}', "" + parameters['sponsorId']);
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        var keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(function (key) { return key + '=' + encodeURIComponent(queryParameters[key]); }).join('&')) : '');
    };
    /**
    * This is a method that retrieves metadata about all the conversations in a sponsor's organizations.
                    The organizations are constrained to those the caller can see.
    * @method
    * @name ConversationLists#GetSponsorOrganizationConversationsMetaData
         * @param {string} distributorId - The distributor identifier.
         * @param {string} sponsorId - The sponsor identifier.
         * @param {string} authorization - access token
    */
    ConversationLists.prototype.GetSponsorOrganizationConversationsMetaData = function (parameters) {
        var _this = this;
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/conversations/metadata';
        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};
        return new Promise(function (resolve, reject) {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{distributorId}', "" + parameters['distributorId']);
            if (parameters['distributorId'] === undefined) {
                reject(new Error('Missing required  parameter: distributorId'));
                return;
            }
            path = path.replace('{sponsorId}', "" + parameters['sponsorId']);
            if (parameters['sponsorId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorId'));
                return;
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            _this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    };
    ConversationLists.prototype.GetOrganizationConversationsURL = function (parameters) {
        var queryParameters = {};
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/organizations/{organizationId}/conversations';
        path = path.replace('{distributorId}', "" + parameters['distributorId']);
        path = path.replace('{sponsorId}', "" + parameters['sponsorId']);
        path = path.replace('{organizationId}', "" + parameters['organizationId']);
        if (parameters['fromDateTime'] !== undefined) {
            queryParameters['fromDateTime'] = parameters['fromDateTime'];
        }
        if (parameters['toDateTime'] !== undefined) {
            queryParameters['toDateTime'] = parameters['toDateTime'];
        }
        if (parameters['tags'] !== undefined) {
            queryParameters['tags'] = parameters['tags'];
        }
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        var keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(function (key) { return key + '=' + encodeURIComponent(queryParameters[key]); }).join('&')) : '');
    };
    /**
    * This is a method that retrieves a list of all of an organization's conversations, optionally within a specified date range.
    * @method
    * @name ConversationLists#GetOrganizationConversations
         * @param {string} distributorId - The distributor identifier.
         * @param {string} sponsorId - The sponsor identifier.
         * @param {string} organizationId - The organization identifier.
         * @param {string} fromDateTime - The beginning point, in UTC, from which to search for conversations, inclusive. May be
                    omitted.
         * @param {string} toDateTime - The endpoints point, in UTC, to which to search for conversations, inclusive. May be omitted.
         * @param {string} tags - A CSV list of tags that may be used to filter which conversations are returned. Placing an ! in front of
                    a tag (e.g. !Inbox) will result in conversations with that tag being excluded. If more than one tag is present in
                    the list,
                    all tags must be present on the conversation in order for it to be included. Parameter is optional.
         * @param {string} authorization - access token
    */
    ConversationLists.prototype.GetOrganizationConversations = function (parameters) {
        var _this = this;
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/organizations/{organizationId}/conversations';
        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};
        return new Promise(function (resolve, reject) {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{distributorId}', "" + parameters['distributorId']);
            if (parameters['distributorId'] === undefined) {
                reject(new Error('Missing required  parameter: distributorId'));
                return;
            }
            path = path.replace('{sponsorId}', "" + parameters['sponsorId']);
            if (parameters['sponsorId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorId'));
                return;
            }
            path = path.replace('{organizationId}', "" + parameters['organizationId']);
            if (parameters['organizationId'] === undefined) {
                reject(new Error('Missing required  parameter: organizationId'));
                return;
            }
            if (parameters['fromDateTime'] !== undefined) {
                queryParameters['fromDateTime'] = parameters['fromDateTime'];
            }
            if (parameters['toDateTime'] !== undefined) {
                queryParameters['toDateTime'] = parameters['toDateTime'];
            }
            if (parameters['tags'] !== undefined) {
                queryParameters['tags'] = parameters['tags'];
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            _this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    };
    ConversationLists.prototype.GetUserConversationsURL = function (parameters) {
        var queryParameters = {};
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/users/{userId}/conversations';
        path = path.replace('{distributorId}', "" + parameters['distributorId']);
        path = path.replace('{sponsorId}', "" + parameters['sponsorId']);
        path = path.replace('{userId}', "" + parameters['userId']);
        if (parameters['fromDateTime'] !== undefined) {
            queryParameters['fromDateTime'] = parameters['fromDateTime'];
        }
        if (parameters['toDateTime'] !== undefined) {
            queryParameters['toDateTime'] = parameters['toDateTime'];
        }
        if (parameters['tags'] !== undefined) {
            queryParameters['tags'] = parameters['tags'];
        }
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        var keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(function (key) { return key + '=' + encodeURIComponent(queryParameters[key]); }).join('&')) : '');
    };
    /**
    * This is a method that retrieves a list of all of a user's conversations, optionally within a specified date range.
    * @method
    * @name ConversationLists#GetUserConversations
         * @param {string} distributorId - The distributor identifier.
         * @param {string} sponsorId - The sponsor identifier.
         * @param {string} userId - The user identifier.
         * @param {string} fromDateTime - The beginning point, in UTC, from which to search for conversations, inclusive. May be omitted.
         * @param {string} toDateTime - The endpoints point, in UTC, to which to search for conversations, inclusive. May be omitted.
         * @param {string} tags - A CSV list of tags that may be used to filter which conversations are returned. Placing an ! in front of
                    a tag (e.g. !Inbox) will result in conversations with that tag being excluded. If more than one tag is present in
                    the list,
                    all tags must be present on the conversation in order for it to be included. Parameter is optional.
         * @param {string} authorization - access token
    */
    ConversationLists.prototype.GetUserConversations = function (parameters) {
        var _this = this;
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/users/{userId}/conversations';
        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};
        return new Promise(function (resolve, reject) {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{distributorId}', "" + parameters['distributorId']);
            if (parameters['distributorId'] === undefined) {
                reject(new Error('Missing required  parameter: distributorId'));
                return;
            }
            path = path.replace('{sponsorId}', "" + parameters['sponsorId']);
            if (parameters['sponsorId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorId'));
                return;
            }
            path = path.replace('{userId}', "" + parameters['userId']);
            if (parameters['userId'] === undefined) {
                reject(new Error('Missing required  parameter: userId'));
                return;
            }
            if (parameters['fromDateTime'] !== undefined) {
                queryParameters['fromDateTime'] = parameters['fromDateTime'];
            }
            if (parameters['toDateTime'] !== undefined) {
                queryParameters['toDateTime'] = parameters['toDateTime'];
            }
            if (parameters['tags'] !== undefined) {
                queryParameters['tags'] = parameters['tags'];
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            _this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    };
    ConversationLists.prototype.GetPatientConversationsURL = function (parameters) {
        var queryParameters = {};
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/patients/{patientId}/conversations';
        path = path.replace('{patientId}', "" + parameters['patientId']);
        if (parameters['fromDateTime'] !== undefined) {
            queryParameters['fromDateTime'] = parameters['fromDateTime'];
        }
        if (parameters['toDateTime'] !== undefined) {
            queryParameters['toDateTime'] = parameters['toDateTime'];
        }
        if (parameters['tags'] !== undefined) {
            queryParameters['tags'] = parameters['tags'];
        }
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        var keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(function (key) { return key + '=' + encodeURIComponent(queryParameters[key]); }).join('&')) : '');
    };
    /**
    * This is a method that retrieves a list of all of a patient's conversations, optionally within a specified date range.
    * @method
    * @name ConversationLists#GetPatientConversations
         * @param {string} patientId - The patient identifier.
         * @param {string} fromDateTime - The beginning point, in UTC, from which to search for conversations, inclusive. May be omitted.
         * @param {string} toDateTime - The endpoints point, in UTC, to which to search for conversations, inclusive. May be omitted.
         * @param {string} tags - A CSV list of tags that may be used to filter which conversations are returned. Placing an ! in front of
                    a tag (e.g. !Inbox) will result in conversations with that tag being excluded. If more than one tag is present in
                    the list,
                    all tags must be present on the conversation in order for it to be included. Parameter is optional
         * @param {string} authorization - access token
    */
    ConversationLists.prototype.GetPatientConversations = function (parameters) {
        var _this = this;
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/patients/{patientId}/conversations';
        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};
        return new Promise(function (resolve, reject) {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{patientId}', "" + parameters['patientId']);
            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }
            if (parameters['fromDateTime'] !== undefined) {
                queryParameters['fromDateTime'] = parameters['fromDateTime'];
            }
            if (parameters['toDateTime'] !== undefined) {
                queryParameters['toDateTime'] = parameters['toDateTime'];
            }
            if (parameters['tags'] !== undefined) {
                queryParameters['tags'] = parameters['tags'];
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            _this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    };
    ConversationLists.prototype.GetPatientConversationsSponsorIdentifierURL = function (parameters) {
        var queryParameters = {};
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/patients/{patientId}/conversations';
        path = path.replace('{distributorId}', "" + parameters['distributorId']);
        path = path.replace('{sponsorId}', "" + parameters['sponsorId']);
        path = path.replace('{patientId}', "" + parameters['patientId']);
        if (parameters['fromDateTime'] !== undefined) {
            queryParameters['fromDateTime'] = parameters['fromDateTime'];
        }
        if (parameters['toDateTime'] !== undefined) {
            queryParameters['toDateTime'] = parameters['toDateTime'];
        }
        if (parameters['tags'] !== undefined) {
            queryParameters['tags'] = parameters['tags'];
        }
        if (parameters.$queryParameters) {
            Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                queryParameters[parameterName] = parameters.$queryParameters[parameterName];
            });
        }
        var keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(function (key) { return key + '=' + encodeURIComponent(queryParameters[key]); }).join('&')) : '');
    };
    /**
    * This is a method that retrieves a list of all of a patient's conversations, optionally within a specified date range.
    * @method
    * @name ConversationLists#GetPatientConversationsSponsorIdentifier
         * @param {string} distributorId - The distributor identifier.
         * @param {string} sponsorId - The sponsor identifier.
         * @param {string} patientId - The patient identifier.
         * @param {string} fromDateTime - The beginning point, in UTC, from which to search for conversations, inclusive. May be omitted.
         * @param {string} toDateTime - The endpoints point, in UTC, to which to search for conversations, inclusive. May be omitted.
         * @param {string} tags - A CSV list of tags that may be used to filter which conversations are returned. Placing an ! in front of
                    a tag (e.g. !Inbox) will result in conversations with that tag being excluded. If more than one tag is present in
                    the list,
                    all tags must be present on the conversation in order for it to be included. Parameter is optional
         * @param {string} authorization - access token
    */
    ConversationLists.prototype.GetPatientConversationsSponsorIdentifier = function (parameters) {
        var _this = this;
        var domain = parameters.$domain ? parameters.$domain : this.domain;
        var path = '/api/distributors/{distributorId}/sponsors/{sponsorId}/patients/{patientId}/conversations';
        var body;
        var queryParameters = {};
        var headers = {};
        var form = {};
        return new Promise(function (resolve, reject) {
            headers['Accept'] = 'application/json, text/json, application/xml, text/xml';
            headers['Content-Type'] = '';
            path = path.replace('{distributorId}', "" + parameters['distributorId']);
            if (parameters['distributorId'] === undefined) {
                reject(new Error('Missing required  parameter: distributorId'));
                return;
            }
            path = path.replace('{sponsorId}', "" + parameters['sponsorId']);
            if (parameters['sponsorId'] === undefined) {
                reject(new Error('Missing required  parameter: sponsorId'));
                return;
            }
            path = path.replace('{patientId}', "" + parameters['patientId']);
            if (parameters['patientId'] === undefined) {
                reject(new Error('Missing required  parameter: patientId'));
                return;
            }
            if (parameters['fromDateTime'] !== undefined) {
                queryParameters['fromDateTime'] = parameters['fromDateTime'];
            }
            if (parameters['toDateTime'] !== undefined) {
                queryParameters['toDateTime'] = parameters['toDateTime'];
            }
            if (parameters['tags'] !== undefined) {
                queryParameters['tags'] = parameters['tags'];
            }
            if (parameters['authorization'] !== undefined) {
                headers['Authorization'] = parameters['authorization'];
            }
            if (parameters['authorization'] === undefined) {
                reject(new Error('Missing required  parameter: authorization'));
                return;
            }
            if (parameters.$queryParameters) {
                Object.keys(parameters.$queryParameters).forEach(function (parameterName) {
                    queryParameters[parameterName] = parameters.$queryParameters[parameterName];
                });
            }
            _this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve);
        });
    };
    return ConversationLists;
}(ApiClass));
export default ConversationLists;
//# sourceMappingURL=conversation-lists.js.map